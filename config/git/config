[core]
    pager = sed 's/\t/>   /g' | less -R
    editor = nvim
[alias]
    ap = -c interactive.diffFilter="git diff --color | sed 's/\t/>   /g'" add -p
    lg = log --all --graph --color=always --format='%C(auto)%h%d %s %C(black)%C(bold)%cr %C(dim magenta)%an %ad'
    l  = log --all --graph --color=always --format='%C(auto)%h%d %s %C(black)%C(bold)%cr %C(dim magenta)%an'
    lc = log       --graph --color=always --format='%C(auto)%h%d %s %C(black)%C(bold)%cr %C(dim magenta)%an'
    lfp= log       --graph --color=always --format='%C(auto)%h%d %s %C(black)%C(bold)%cr %C(dim magenta)%an'
    fa = fetch --all
    co = checkout
    su = status -s
    st = !git --no-pager diff --stat
    amend = commit --amend
    rod = rebase -i origin/develop
    rc = rebase --continue
    rl = remote -v
    pu = "!f(){ git push origin \"${1-$(git rev-parse --abbrev-ref HEAD)}\"; }; f"
    puf= "!f(){ git push origin \"${1-$(git rev-parse --abbrev-ref HEAD)}\" --force; }; f"
    yolo="!f(){ git commit -m \"$(curl -s https://whatthecommit.com/index.txt)\"; }; f"
    rho= "!f(){ git reset --hard \"origin/$(git rev-parse --abbrev-ref HEAD)\"; }; f"
    dio= "!f(){ git diff \"origin/$(git rev-parse --abbrev-ref HEAD)\"; }; f"
    fc = "!f(){ nvim +/HEAD -p $(git diff --relative --name-only --diff-filter=U); }; f"
    brename = "!f() { git rev-parse --abbrev-ref HEAD > /tmp/git_branch_rename && vim /tmp/git_branch_rename && git branch -m \"$(cat /tmp/git_branch_rename)\"; }; f"

    ; use git cut {commit sha} {directory1} {file2} {etc}
    cut = "!f(){ cd ${GIT_PREFIX:-.}; sha=$1;shift; git show ${sha} $@ > /tmp/patch.patch; }; f"
    cutapplyrd = "!f(){ git apply --reverse /tmp/patch.patch && git commit --amend --no-edit; }; f"
    cutapplyr = "!f(){ git apply --cached --reverse /tmp/patch.patch && git commit --amend --no-edit; }; f"
    cutapply = "!f(){ git apply --cached /tmp/patch.patch && git commit; }; f"
    cutshow = "!f(){ less /tmp/patch.patch; }; f"

    ; Edit current commit as patch and create a new commit with what's remain in the patch
    dsplitp = "!f(){ cd ${GIT_PREFIX:-.};git cut HEAD $@ && nvim /tmp/patch.patch && git cutapplyr && git cutapply; }; f"

    ; use git dcherry {commit sha} {directory1} {file2} {etc}
    ; This is like cherry pick but you can select directory and files
    dcherry = "!f(){ cd ${GIT_PREFIX:-.};git cut $@ && git cutapply; }; f"

    ; use git dsplit {directory1} {file2} {etc}
    ; this will remove all change related to the selected file/dir for the current commit and create a new commit with those change
    dsplit = "!f(){ cd ${GIT_PREFIX:-.};git cut HEAD $@ && git cutapplyr && git cutapply; }; f"

    ddelete = "!f(){ cd ${GIT_PREFIX:-.};git cut HEAD $@ && git cutapplyrd; }; f"

    ; use git massrename sha1 sha2
    ; This will apply all commit from sha1(first commit) to sha2(last commit) to your current branch but before you can edit all the commit as patch
    ;massrename = "!f(){ cd ${GIT_PREFIX:-.}; git format-patch HEAD..$1 --stdout > /tmp/patch.patch; nvim /tmp/patch.patch; git am /tmp/patch.patch; }; f"
    massrename = "!f(){ cd ${GIT_PREFIX:-.}; git_mass_rename.sh $1; }; f"

    grog = log --graph --abbrev-commit --decorate --all --format=format:\"%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(dim white) - %an%C(reset) %C(bold green)(%ar)%C(reset)%C(bold yellow)%d%C(reset)%n %C(white)%s%C(reset)\"
    fixup = commit --fixup
[merge]
    tool = nvim
    renameLimit = 999999
[mergetool "nvim"]
    cmd = nvim -f -c \"Gdiff\" \"$MERGED\"
[diff "json"]
    textconv = jq "." --sort-keys
[user]
	email = leoman037@live.fr
	name = lguard
[push]
	default = current
[submodule]
	recurse = true
[rebase]
	autosquash = true
